# 장치 트리 소개
장치 트리는 컴퓨터 시스템의 하드웨어 요소를 정의하는 유연한 방법이다. 장치 트리는 실행 코드가 아닌 정적 데이터일 뿐이다. 보통 장치 트리는 부트로더가 로드해서 커널에 넘긴다. 또한 장치 트리를 따로 로드할 수 없는 부트로더를 위해 커널 이미지 자체에 포함시킬 수 있다.
[웹 사이트](https://www.devicetree.org/)

## 장치 트리 기초
장치 트리는 컴퓨터 시스템을 나무 같은 계층 구조로 결합된 요소의 묶음으로 나타낸다. 장치 트리는 슬래시(/)로 나타내는 루트 노드로 시작하고, 루트 노드는 시스템의 하드웨어를 나타내는 그다음 노드들을 포함한다. 각 노드는 그 이름을 갖고, 이름 = "값" 형태의 여러 프로퍼티(property)를 담고 있다. 다음은 그 예다.
```dts
/dts-v1/;
/{
    model = "TI AM335x BeagleBone";
    compatible = "ti,am33xx";
    #address-cells = <1>;
    #size-cells=<1>;
    cpus {
    #address-cells = <1>;
    #size-cells=<0>;
        cpu@0 {
            compatible = "arm,cortex-a8";
            device_type = "cpu";
            reg = <0>;
        };
    };
    memory@0x80000000 {
        device_type = "memory";
        reg = <0x80000000 0x20000000>;
    };
};
```
여기서 루트 노드는 `cpus` 노드와 `memory` 노드를 담고 있다. `cpus` 노드는 이름이 `cpu@0`인 하나의 `CPU` 노드를 담고 있다. 노드 이름 끝에 `@`과, 같은 종류의 다른 노드와 구별하는 주소가 포함되는 것이 일반적인 관례다. 노드에 `reg`속성이 있는 경우 `@`이 필요하다.

루트와 **CPU** 노드에는 **compatible** 프로퍼티가 있다. 리눅스 커널은 이 프로퍼티를 이용해서 장치 드라이버가 **of_device_id** 구조체에 저장해둔 문자열과 비교해 일치하는 장치 드라이버를 찾는다.

**CPU** 노드와 메모리 노드에는 **device_type** 프로퍼티가 있으며, 장치의 종류를 나타낸다. 노드 이름은 흔히 **device_type**에서 유래한다.

### reg 프로퍼티
메모리와 **CPU** 노드에는 **reg**프로퍼티가 있는데, 레지스터 공간에 있는 구성 단위의 범위를 나타낸다. **reg** 프로퍼티는 범위의 시작 주소와 크기(길이)로 이뤄지는데, 둘 다 셀(cell)이라는 0개 이상의 32비트 정수로 나타낸다. 따라서 메모리 노드는 **0x80000000**에서 시작하는 **0x20000000**바이트 길이의 단일 뱅크 메모리를 나타낸다.

주소나 크기를 32비트로 나타낼 수 없는 경우, **reg** 프로퍼티를 이해하기가 더 복잡해진다. 예를 들어 64비트 주소를 쓰는 장치의 경우, 각각 두 셀이 필요하다.
```dts
/ {
    #address-cells = <2>;
    #size-cells = <2>;
    memory@80000000{
        device_type = "memory";
        reg = <0x00000000 0x80000000 0 0x80000000>;
    };
}
```
필요한 셀의 개수에 대한 정보는 조상 노드의 **#address-cells**와 **size-cells**에 선언돼 있다. 즉, **reg** 프로퍼티를 이해하려면 **#address-cells**와 **#size-cells** 프로퍼티를 찾을 때까지 노드 계층 구조를 되짚어봐야 한다. 찾을 수 없다면 기본값은 1이지만, 트리 작성자가 만일의 사태에 대한 대비책에 의존하는 것은 좋지 않은 습관이다.

## 레이블과 인터럽트
지금까지 설명한 장치 트리의 구조는 요소들 간에 단일 계층 구조가 있다고 가정하지만, 사실은 여러 계층 구조가 존재한다. 요소와 시스템의 다른 부분들 사이의 명백한 자료 연결뿐만 아니라 인터럽트 제어기, 클럭 공급원(clock source), 전압 조정기에도 연결돼 있을 수 있다. 이들 연결을 나타내기 위해 노드에 레이블을 추가하고 다른 노드에서 그 레이블을 참조할 수 있다. 이 레이블은 **phandle**이라고 한다. 장치 트리가 컴파일되면, 다른 노드에서 참조하는 노드에 **phandle**이라는 프로퍼티에 고유한 수치가 할당되기 때문이다. 장치 트리 바이너리를 디컴파일하면 그 수치를 볼 수 있다.

인터럽트를 만들 수 있는 LCD 제어기와 인터럽트 제어기를 갖고 있는 시스템을 예로 들어보자.
```dts
/dts-v1/;
{
    intc: interrupt-controller@48200000 {
        compatible = "ti,am33xx-intc";
        interrupt-controller;
        #interrupt-cells = <1>;
        reg = <0x48200000 0x1000>;
    };
    lcdc: lcdc@4830e000 {
        compatible = "ti,am33xx-tilcdc";
        reg = <0x4830e000 0x1000>;
        interrupt-parent = <&intc>;
        interrupts = <36>;
        ti,hwmods = "lcdc";
        status = "disabled";
    };
};
```
**interrupt-controller@48200000** 노드에는 레이블 **intc**가 붙어있다. **interrupt-controller** 프로퍼티를 보면 해당 노드가 인터럽트 제어기임을 알 수 있다. 모든 인터럽트 제어기와 마찬가지로 **#interrupt-cells** 프로퍼티를 갖고 있는데, 인터럽트 소스를 나타내기 위해 필요한 셀의 수를 알려준다. 이 경우 **IRQ** 번호를 나타내는 셀 하나만 있으면 된다. 다른 인터럽트 제어기는 인터럽트 제어기는 인터럽트의 특징(예: 에지 트리거인지 레벨 트리거 인지)을 나타내기 위해 셀을 추가로 사용할 수도 있다. 인터럽트 셀의 수와 의미는 인터럽트 제어기별 바인딩에 설명돼 있다.

**lcdc@4830e000**노드에는 **interrupt-parent** 프로퍼티가 있는데, 연결된 인터럽트 제어기를 레이블을 통해 참조한다. **interrupts** 프로퍼티가 있으며, 이 경우에는 36이다. 이 노드에는 레이블 **lcdc**가 있는데, 다른 곳에서 사용된다. 모든 노드는 레이블을 가질 수 있다.

## 장치 트리 인클루드 파일
장치 트리 인클루드 파일은 공통 하드웨어 정의를 재사용하기 위해 만드는 조각 파일이며, 보통 확장자는 **.dtsi**이고, 최상위 보드 파일 **.dts**에서 여러 .dtsi를 포함(include) 해서 최종 트리를 구성한다.

많은 하드웨어가 같은 종류의 **SoC**사이에, 그리고 같은 **SoC**를 사용하는 보드 사이에 공통적이다. 이는 장치 트리에도 반영돼서 공통 부분을 인클루드(include)파일로 분리할 수 있다. 오픈 펌웨어 표준은 **/include/**를 그 방법으로 정의하고, **vexpress-v2p-ca9.dts**에서 발췌한 다음 예처럼 사용한다.
```dts
/include/ "vexpress-v2m.dtsi"
```
커널에 있는 **.dts** 파일들을 살펴보면 **C**에서 빌려온 또 다른 **include**문을 찾을 수 있다.

